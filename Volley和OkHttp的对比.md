Volley和OkHttp之间的比较

https://www.jianshu.com/p/33be82da8f25

Volley，它的设计目标就是非常适合去进行数据量不大，但通信频繁的网络操作，而对于大数据量的网络操作，比如说下载文件等，Volley的表现就会非常糟糕。


物理质量

使用Volley，需要Volley.jar(120k)，加上自己的封装最多140k。
使用OkHttp需要okio.jar (80k), okhttp.jar(330k)这2个jar包，总大小差不多400k,加上自己的封装，差不多得410k。

Volley的优点

非常适合进行数据量不大，但通信频繁的网络操作
可直接在主线程调用服务端并处理返回结果
可以取消请求，容易扩展，面向接口编程
网络请求线程NetworkDispatcher默认开启了4个，可以优化，通过手机CPU数量
通过使用标准的HTTP缓存机制保持磁盘和内存响应的一致

Volley的缺点

2.3之前使用的是httpclient，2.3之后使用的是HttpURLConnection
6.0不支持httpclient了，如果想支持得添加org.apache.http.legacy.jar
对大文件下载 Volley的表现非常糟糕
只支持http请求，不支持HTTPS
图片加载性能一般


OKHttp的优点

支持HTTP和HTTPS
支持各种请求方式，包括大文件的下载和上传
支持同步和异步请求
支持自定义拦截器和缓存方式
支持多种解码方式以及扩展性很高

OKHttp的缺点

不能直接运行在主线程，需要通过在子线程中请求，并且接收响应结果的回调时也不能在主线程中操作
不同的请求内容不能共用一个回调接口

Volley的工作过程

首先通过Volley.newRequestQueue(context)创建一个请求队列，在队列创建后并初始化一个缓存分派类，实际上是一个Thread，
然后还会初始化四个网络处理的分派类NetworkDispatcher，实际上也是Thread，并启动它们。
然后就是声明请求，封装我们要请求的内容，交给Request的子类处理。
再把请求加入到请求队列里面，缓存分派类里面执行了一个while(true)循环，它监听到队列中有请求后就会取出，并去本地缓存的地方去找是否
已经有该请求的响应内容。
如果有就直接把缓存的响应结果取出回调给外部的Request的parseNetworkResponse()方法处理，这个方法的主要任务是
解析响应的结果为我们需要的形式。
如果本地缓存并没有这个请求对应的响应内容，则把请求分发给空闲的NetworkDispatcher来处理，NetworkDispatcher在处理的时候会判断
当前系统的版本，如果小于2.3就会采用httpclient客户端，如果大于2.3就会使用httpurlconnection客户端，使用合适的客户端处理请求后
会返回一个响应结果Response,之后就是把这个响应结果回调给外部的Request的parseNetworkResponse()方法处理。这就是Volley的工作过程。

okhttp的工作过程

首先获得一个默认配置的okhttpclient，当前也可以通过他的内部类Builder去更改，然后就是声明请求Request，传入请求的URL和请求参数，
再调用Okhttpclient的newCall方法将请求包装为一个call类，如果是异步执行接着就是将这个call对象加入到请求队列中，然后交给请求队列
的分派类去分派并声明一个回调接口对象，如果是同步执行接着直接调用call类的excute方法并直接获得一个响应结果，不管是在分派类分派异步执行
的请求还是同步执行时，接着都会将请求传递给一系列的拦截器来处理，这些拦截器都各自有自己的任务要处理，比如有缓存管理拦截器，失败重试和
重定向拦截器，网络连接管理器，请求和响应处理拦截器等等，他们是按照顺序来传递请求，根据责任链的模式，如果请求在当前拦截器未做处理就会
把请求传递到下一层，直到传递到请求和响应处理拦截器里面，就会真正的去执行请求，在这个拦截器里面是通过一个HTTPcodec类来实现的，
他会把请求数据写入socket的输出流中，并且从输入流中再读取服务器返回的数据交给拦截器，拦截器再把响应结果会交给回调接口，
这就是okhttp的请求过程。
